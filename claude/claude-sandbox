#!/usr/bin/env bash
# claude-sandbox - Run Claude Code in a sandboxed Docker container
# Drop this in your PATH (e.g., ~/.local/bin/claude-sandbox)

set -e

IMAGE_NAME="claude-sandbox"
CONTAINER_NAME="claude-sandbox-$$"
# Use a host directory instead of Docker volume for auth persistence
# Docker volumes are created as root, causing permission issues with --user
AUTH_DIR="$HOME/.claude-sandbox-auth"

# Egress filter proxy settings
PROXY_CONTAINER_NAME="claude-sandbox-proxy"
PROXY_NETWORK_NAME="claude-sandbox-net"
PROXY_PORT=3128
PROXY_IMAGE="claude-sandbox-proxy"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

usage() {
    echo "Usage: claude-sandbox [OPTIONS] [CLAUDE_ARGS...]"
    echo ""
    echo "Run Claude Code in a sandboxed Docker container"
    echo ""
    echo "Options:"
    echo "  -b, --build       Force rebuild the Docker image"
    echo "  -s, --shell       Start a bash shell instead of Claude"
    echo "  -n, --no-commit   Block git commits (default: commits allowed, push blocked)"
    echo "  -p, --port PORT   Expose a port (can be used multiple times)"
    echo "  -a, --auth        Run Claude on host (not Docker) to authenticate plugins"
    echo "  --network-audit     Test egress filtering (verify allowed/blocked domains)"
    echo "  --no-egress-filter  Disable network egress filtering (for debugging)"
    echo "  --cleanup           Stop proxy container and remove internal network"
    echo "  -h, --help        Show this help message"
    echo ""
    echo "Examples:"
    echo "  claude-sandbox                    # Start Claude in current directory"
    echo "  claude-sandbox --auth             # Authenticate plugins (run on host)"
    echo "  claude-sandbox --network-audit    # Verify network egress filtering"
    echo "  claude-sandbox --shell            # Get a shell in the sandbox"
    echo "  claude-sandbox -b                 # Rebuild image and start Claude"
    echo "  claude-sandbox -n                 # Block commits, require host review"
    echo "  claude-sandbox -p 3000 -p 8080    # Expose ports 3000 and 8080"
    echo "  claude-sandbox \"fix the tests\"    # Start Claude with initial prompt"
}

build_image() {
    echo -e "${YELLOW}Building Docker image...${NC}"

    # Check for Dockerfile in known locations
    DOCKERFILE=""
    if [[ -f "$HOME/.config/claude-sandbox/Dockerfile" ]]; then
        DOCKERFILE="$HOME/.config/claude-sandbox/Dockerfile"
    elif [[ -f "$HOME/.claude-sandbox/Dockerfile" ]]; then
        DOCKERFILE="$HOME/.claude-sandbox/Dockerfile"
    else
        echo -e "${RED}Error: Dockerfile not found${NC}"
        echo "Place Dockerfile.claude-sandbox at one of:"
        echo "  ~/.config/claude-sandbox/Dockerfile"
        echo "  ~/.claude-sandbox/Dockerfile"
        exit 1
    fi

    # Resolve symlink to get actual path (Docker doesn't follow symlinks well)
    DOCKERFILE="$(readlink -f "$DOCKERFILE")"
    echo -e "Using dockerfile at: ${DOCKERFILE}"

    # Build with logging - use script to preserve TTY colors while capturing output
    local log_file="$AUTH_DIR/build.log"
    mkdir -p "$AUTH_DIR"

    echo "Build started at $(date)" > "$log_file"
    echo "Dockerfile: $DOCKERFILE" >> "$log_file"
    echo "---" >> "$log_file"

    # Use timestamp as cache-buster to force fresh Claude Code install
    # 'script' preserves TTY so docker shows colors/progress, while also logging
    local build_status=0
    if [[ "$(uname)" == "Darwin" ]]; then
        # macOS: script -q logfile command...
        script -q "$log_file.raw" docker build --build-arg CLAUDE_CACHEBUST="$(date +%s)" \
            -t "$IMAGE_NAME" -f "$DOCKERFILE" "$(dirname "$DOCKERFILE")" || build_status=$?
    else
        # Linux: script -q -c "command" logfile
        script -q -c "docker build --build-arg CLAUDE_CACHEBUST=\"$(date +%s)\" \
            -t \"$IMAGE_NAME\" -f \"$DOCKERFILE\" \"$(dirname "$DOCKERFILE")\"" "$log_file.raw" || build_status=$?
    fi

    # Strip ANSI codes for clean log, append to main log
    sed 's/\x1b\[[0-9;]*m//g' "$log_file.raw" >> "$log_file" 2>/dev/null || cat "$log_file.raw" >> "$log_file"
    rm -f "$log_file.raw"

    if [[ $build_status -eq 0 ]]; then
        echo -e "${GREEN}Image built successfully${NC}"
        echo "---" >> "$log_file"
        echo "Build completed successfully at $(date)" >> "$log_file"
    else
        echo -e "${RED}Build failed!${NC}"
        echo -e "Log saved to: ${YELLOW}$log_file${NC}"
        echo "---" >> "$log_file"
        echo "Build FAILED at $(date)" >> "$log_file"
        exit 1
    fi
}

ensure_image() {
    if ! docker image inspect "$IMAGE_NAME" &>/dev/null; then
        echo -e "${YELLOW}Image not found, building...${NC}"
        build_image
    fi
}

ensure_auth_dir() {
    if [[ ! -d "$AUTH_DIR" ]]; then
        echo -e "${YELLOW}Creating auth directory...${NC}"
        mkdir -p "$AUTH_DIR"
    fi

    # Ensure settings.json has read-only deny list.
    # Bypass permissions is NOT set here -- it's passed as a CLI flag only in
    # Docker sandbox mode. Auth mode uses normal interactive permissions so the
    # user can review what Claude does on the host.
    # Claude Code may create/modify this file when you approve commands,
    # so we need to update it in place rather than overwrite it
    # Deny list last audited: 2026-02-19. Re-audit write tools after plugin updates.
    local settings_file="$AUTH_DIR/settings.json"
    if [[ ! -f "$settings_file" ]]; then
        echo -e "${YELLOW}Creating settings with read-only deny list...${NC}"
        cat > "$settings_file" <<'SETTINGS'
{
  "permissions": {
    "allow": [],
    "deny": [
      "mcp__claude_ai_Slack__slack_send_message",
      "mcp__claude_ai_Slack__slack_send_message_draft",
      "mcp__claude_ai_Slack__slack_schedule_message",
      "mcp__claude_ai_Slack__slack_create_canvas",
      "mcp__claude_ai_Linear__create_attachment",
      "mcp__claude_ai_Linear__create_comment",
      "mcp__claude_ai_Linear__create_document",
      "mcp__claude_ai_Linear__create_initiative",
      "mcp__claude_ai_Linear__create_issue",
      "mcp__claude_ai_Linear__create_issue_label",
      "mcp__claude_ai_Linear__create_milestone",
      "mcp__claude_ai_Linear__create_project",
      "mcp__claude_ai_Linear__delete_attachment",
      "mcp__claude_ai_Linear__delete_status_update",
      "mcp__claude_ai_Linear__save_status_update",
      "mcp__claude_ai_Linear__update_document",
      "mcp__claude_ai_Linear__update_initiative",
      "mcp__claude_ai_Linear__update_issue",
      "mcp__claude_ai_Linear__update_milestone",
      "mcp__claude_ai_Linear__update_project",
      "mcp__claude_ai_Notion__notion-create-comment",
      "mcp__claude_ai_Notion__notion-create-database",
      "mcp__claude_ai_Notion__notion-create-pages",
      "mcp__claude_ai_Notion__notion-duplicate-page",
      "mcp__claude_ai_Notion__notion-move-pages",
      "mcp__claude_ai_Notion__notion-update-data-source",
      "mcp__claude_ai_Notion__notion-update-page",
      "mcp__pylon__pylon_create_account",
      "mcp__pylon__pylon_update_account",
      "mcp__pylon__pylon_delete_account",
      "mcp__pylon__pylon_create_contact",
      "mcp__pylon__pylon_update_contact",
      "mcp__pylon__pylon_delete_contact",
      "mcp__pylon__pylon_create_issue",
      "mcp__pylon__pylon_update_issue",
      "mcp__pylon__pylon_delete_issue",
      "mcp__pylon__pylon_snooze_issue",
      "mcp__pylon__pylon_update_issue_followers",
      "mcp__pylon__pylon_redact_message",
      "mcp__pylon__pylon_create_tag",
      "mcp__pylon__pylon_update_tag",
      "mcp__pylon__pylon_delete_tag",
      "mcp__pylon__pylon_create_team",
      "mcp__pylon__pylon_update_team"
    ]
  }
}
SETTINGS
    else
        echo -e "${YELLOW}Updating settings: read-only deny list...${NC}"
        # Use python to safely merge JSON (preserves existing allow list and custom deny entries)
        python3 -c "
import json, sys
settings_file = sys.argv[1]
try:
    with open(settings_file, 'r') as f:
        settings = json.load(f)
except (json.JSONDecodeError, ValueError):
    # Corrupted file -- start fresh rather than crashing
    settings = {}
if 'permissions' not in settings:
    settings['permissions'] = {}

# Remove bypassPermissions if previously set -- bypass is now a CLI flag
# passed only in Docker sandbox mode, not stored in settings.json.
if settings['permissions'].get('defaultMode') == 'bypassPermissions':
    del settings['permissions']['defaultMode']

# Required deny list for read-only integrations
required_deny = [
    'mcp__claude_ai_Slack__slack_send_message',
    'mcp__claude_ai_Slack__slack_send_message_draft',
    'mcp__claude_ai_Slack__slack_schedule_message',
    'mcp__claude_ai_Slack__slack_create_canvas',
    'mcp__claude_ai_Linear__create_attachment',
    'mcp__claude_ai_Linear__create_comment',
    'mcp__claude_ai_Linear__create_document',
    'mcp__claude_ai_Linear__create_initiative',
    'mcp__claude_ai_Linear__create_issue',
    'mcp__claude_ai_Linear__create_issue_label',
    'mcp__claude_ai_Linear__create_milestone',
    'mcp__claude_ai_Linear__create_project',
    'mcp__claude_ai_Linear__delete_attachment',
    'mcp__claude_ai_Linear__delete_status_update',
    'mcp__claude_ai_Linear__save_status_update',
    'mcp__claude_ai_Linear__update_document',
    'mcp__claude_ai_Linear__update_initiative',
    'mcp__claude_ai_Linear__update_issue',
    'mcp__claude_ai_Linear__update_milestone',
    'mcp__claude_ai_Linear__update_project',
    'mcp__claude_ai_Notion__notion-create-comment',
    'mcp__claude_ai_Notion__notion-create-database',
    'mcp__claude_ai_Notion__notion-create-pages',
    'mcp__claude_ai_Notion__notion-duplicate-page',
    'mcp__claude_ai_Notion__notion-move-pages',
    'mcp__claude_ai_Notion__notion-update-data-source',
    'mcp__claude_ai_Notion__notion-update-page',
    'mcp__pylon__pylon_create_account',
    'mcp__pylon__pylon_update_account',
    'mcp__pylon__pylon_delete_account',
    'mcp__pylon__pylon_create_contact',
    'mcp__pylon__pylon_update_contact',
    'mcp__pylon__pylon_delete_contact',
    'mcp__pylon__pylon_create_issue',
    'mcp__pylon__pylon_update_issue',
    'mcp__pylon__pylon_delete_issue',
    'mcp__pylon__pylon_snooze_issue',
    'mcp__pylon__pylon_update_issue_followers',
    'mcp__pylon__pylon_redact_message',
    'mcp__pylon__pylon_create_tag',
    'mcp__pylon__pylon_update_tag',
    'mcp__pylon__pylon_delete_tag',
    'mcp__pylon__pylon_create_team',
    'mcp__pylon__pylon_update_team',
]
existing_deny = set(settings['permissions'].get('deny', []))
merged_deny = sorted(set(required_deny) | existing_deny)
settings['permissions']['deny'] = merged_deny

# Remove plugins that are no longer used
removed_plugins = [
    'atlassian@claude-plugins-official',
    'figma@claude-plugins-official',
    'sentry@claude-plugins-official',
    'github@claude-plugins-official',
]
if 'enabledPlugins' in settings:
    for p in removed_plugins:
        settings['enabledPlugins'].pop(p, None)

with open(settings_file, 'w') as f:
    json.dump(settings, f, indent=2)
" "$settings_file"
    fi

    # Register MCP servers in .claude.json (the file Claude Code actually reads).
    # Claude Code ignores mcp.json -- it reads MCP servers from the top-level
    # "mcpServers" key in $CLAUDE_CONFIG_DIR/.claude.json (user scope).
    #
    # Env vars use ${VAR} syntax which Claude Code expands from its own process.env
    # before passing to MCP subprocesses. This lets the same config work in both
    # auth mode (host exports) and Docker mode (-e flags) with different values.
    #
    # Claude Code's MCP SDK only passes HOME, LOGNAME, PATH, SHELL, TERM, USER
    # from parent env to subprocesses -- all other env vars MUST be in this env block.
    local claude_json="$AUTH_DIR/.claude.json"
    python3 -c "
import json, sys

claude_json_file = sys.argv[1]
try:
    with open(claude_json_file, 'r') as f:
        state = json.load(f)
except (FileNotFoundError, json.JSONDecodeError):
    state = {}

required_mcp = {
    # Google Workspace (read-only OAuth scopes, single-user stdio mode)
    'google-workspace': {
        'command': 'workspace-mcp',
        'args': ['--read-only', '--single-user', '--tools', 'gmail', 'drive', 'calendar', 'docs'],
        'env': {
            'GOOGLE_OAUTH_CLIENT_ID': '\${GOOGLE_OAUTH_CLIENT_ID:-}',
            'GOOGLE_OAUTH_CLIENT_SECRET': '\${GOOGLE_OAUTH_CLIENT_SECRET:-}',
            'WORKSPACE_MCP_CREDENTIALS_DIR': '\${WORKSPACE_MCP_CREDENTIALS_DIR:-}',
            'OAUTHLIB_INSECURE_TRANSPORT': '1',
        },
    },
    # Browser automation (headless Docker; fails silently on host -- that's fine)
    'playwright': {
        'command': 'node',
        'args': ['/usr/lib/node_modules/@playwright/mcp/cli.js', '--browser', 'chromium', '--headless', '--no-sandbox', '--isolated'],
        'env': {},
    },
    # Pylon customer support (write tools blocked by deny list in settings.json)
    'pylon': {
        'command': 'pylon-mcp',
        'args': [],
        'env': {
            'PYLON_API_TOKEN': '\${PYLON_API_TOKEN:-}',
        },
    },
}

changed = False
if 'mcpServers' not in state:
    state['mcpServers'] = {}
    changed = True

added = []
for name, config in required_mcp.items():
    if state['mcpServers'].get(name) != config:
        state['mcpServers'][name] = config
        added.append(name)
        changed = True

# Remove stale servers that are no longer used
stale = ['codex', 'gemini']
for name in stale:
    if name in state['mcpServers']:
        del state['mcpServers'][name]
        changed = True

if changed:
    with open(claude_json_file, 'w') as f:
        json.dump(state, f, indent=2)

if added:
    print(', '.join(added))
" "$claude_json"

    if [[ $? -eq 0 ]]; then
        echo -e "${GREEN}MCP servers registered in .claude.json${NC}"
    fi

    # Sync CLAUDE.md (user-level instructions) from repo into auth dir
    # Look for CLAUDE.md next to the Dockerfile
    local claude_md=""
    if [[ -f "$HOME/.config/claude-sandbox/CLAUDE.md" ]]; then
        claude_md="$HOME/.config/claude-sandbox/CLAUDE.md"
    elif [[ -f "$HOME/.claude-sandbox/CLAUDE.md" ]]; then
        claude_md="$HOME/.claude-sandbox/CLAUDE.md"
    fi

    if [[ -n "$claude_md" ]]; then
        claude_md="$(readlink -f "$claude_md")"
        cp "$claude_md" "$AUTH_DIR/CLAUDE.md"
    fi
}

ensure_proxy_network() {
    # Create the internal network if it doesn't exist
    if ! docker network inspect "$PROXY_NETWORK_NAME" &>/dev/null; then
        echo -e "${YELLOW}Creating internal Docker network: $PROXY_NETWORK_NAME${NC}"
        docker network create --internal "$PROXY_NETWORK_NAME"
    fi
}

ensure_proxy_image() {
    if ! docker image inspect "$PROXY_IMAGE" &>/dev/null; then
        echo -e "${YELLOW}Building proxy image...${NC}"
        local proxy_dockerfile=""
        if [[ -f "$HOME/.config/claude-sandbox/Dockerfile.proxy" ]]; then
            proxy_dockerfile="$HOME/.config/claude-sandbox/Dockerfile.proxy"
        elif [[ -f "$HOME/.claude-sandbox/Dockerfile.proxy" ]]; then
            proxy_dockerfile="$HOME/.claude-sandbox/Dockerfile.proxy"
        else
            echo -e "${RED}Error: Dockerfile.proxy not found${NC}"
            echo "Place it next to your Dockerfile at one of:"
            echo "  ~/.config/claude-sandbox/Dockerfile.proxy"
            echo "  ~/.claude-sandbox/Dockerfile.proxy"
            exit 1
        fi
        proxy_dockerfile="$(readlink -f "$proxy_dockerfile")"
        docker build -t "$PROXY_IMAGE" -f "$proxy_dockerfile" "$(dirname "$proxy_dockerfile")"
    fi
}

ensure_proxy() {
    # Check if proxy container is already running
    if docker ps --format '{{.Names}}' | grep -q "^${PROXY_CONTAINER_NAME}$"; then
        # Verify the running proxy was built from our image (defense-in-depth against
        # a pre-existing container with the same name that doesn't filter traffic)
        local running_image
        running_image=$(docker inspect --format='{{.Config.Image}}' "$PROXY_CONTAINER_NAME" 2>/dev/null || true)
        if [[ "$running_image" != "$PROXY_IMAGE" ]]; then
            echo -e "${RED}WARNING: Proxy container running unexpected image: $running_image (expected: $PROXY_IMAGE)${NC}"
            echo -e "${YELLOW}Stopping and recreating with correct image...${NC}"
            docker stop "$PROXY_CONTAINER_NAME" >/dev/null && docker rm "$PROXY_CONTAINER_NAME" >/dev/null
        else
            echo -e "${GREEN}Proxy container already running${NC}"
            return 0
        fi
    fi

    # Remove stopped proxy container if it exists
    if docker ps -a --format '{{.Names}}' | grep -q "^${PROXY_CONTAINER_NAME}$"; then
        echo -e "${YELLOW}Removing stopped proxy container...${NC}"
        docker rm "$PROXY_CONTAINER_NAME" >/dev/null
    fi

    # Ensure proxy image exists
    ensure_proxy_image

    # Resolve the allowlist file path for volume mounting
    local allowlist_file=""
    if [[ -f "$HOME/.config/claude-sandbox/allowlist.txt" ]]; then
        allowlist_file="$(readlink -f "$HOME/.config/claude-sandbox/allowlist.txt")"
    elif [[ -f "$HOME/.claude-sandbox/allowlist.txt" ]]; then
        allowlist_file="$(readlink -f "$HOME/.claude-sandbox/allowlist.txt")"
    fi

    echo -e "${YELLOW}Starting proxy container...${NC}"

    # Start proxy on bridge network first (so DNS works immediately), then connect
    # to internal network. This avoids DNS errors during squid startup.
    local volume_args=()
    if [[ -n "$allowlist_file" ]]; then
        # Volume-mount the allowlist so users can edit and reload without rebuilding:
        #   docker exec claude-sandbox-proxy squid -k reconfigure
        volume_args=(-v "$allowlist_file:/etc/squid/allowlist.txt:ro")
    fi

    docker run -d \
        --name "$PROXY_CONTAINER_NAME" \
        --restart unless-stopped \
        --memory=256m \
        --cpus=0.5 \
        "${volume_args[@]}" \
        "$PROXY_IMAGE"

    # Connect to the internal network so sandbox containers can reach the proxy
    docker network connect "$PROXY_NETWORK_NAME" "$PROXY_CONTAINER_NAME"

    # Wait for squid to be ready (accepts connections on port 3128)
    echo -e "${YELLOW}Waiting for proxy to be ready...${NC}"
    local retries=0
    local max_retries=30
    while ! docker exec "$PROXY_CONTAINER_NAME" \
        sh -c "echo QUIT | nc localhost $PROXY_PORT >/dev/null 2>&1"; do
        retries=$((retries + 1))
        if [[ $retries -ge $max_retries ]]; then
            echo -e "${RED}Proxy failed to start within ${max_retries}s${NC}"
            echo -e "${RED}Check logs: docker logs $PROXY_CONTAINER_NAME${NC}"
            exit 1
        fi
        sleep 1
    done
    echo -e "${GREEN}Proxy is ready${NC}"
}

cleanup_proxy() {
    echo -e "${YELLOW}Cleaning up egress filter infrastructure...${NC}"
    docker stop "$PROXY_CONTAINER_NAME" 2>/dev/null && docker rm "$PROXY_CONTAINER_NAME" 2>/dev/null || true
    docker network rm "$PROXY_NETWORK_NAME" 2>/dev/null || true
    echo -e "${GREEN}Cleanup complete${NC}"
}

# Parse arguments
FORCE_BUILD=false
START_SHELL=false
NO_COMMIT=false
NO_EGRESS_FILTER=false
DO_CLEANUP=false
AUTH_MODE=false
NETWORK_AUDIT=false
EXPOSED_PORTS=()
CLAUDE_ARGS=()

while [[ $# -gt 0 ]]; do
    case $1 in
        -b|--build)
            FORCE_BUILD=true
            shift
            ;;
        -s|--shell)
            START_SHELL=true
            shift
            ;;
        -n|--no-commit)
            NO_COMMIT=true
            shift
            ;;
        -p|--port)
            if [[ -z "$2" || "$2" == -* ]]; then
                echo -e "${RED}Error: --port requires a port number${NC}"
                exit 1
            fi
            EXPOSED_PORTS+=("$2")
            shift 2
            ;;
        -a|--auth)
            AUTH_MODE=true
            shift
            ;;
        --network-audit)
            NETWORK_AUDIT=true
            shift
            ;;
        --no-egress-filter)
            NO_EGRESS_FILTER=true
            shift
            ;;
        --cleanup)
            DO_CLEANUP=true
            shift
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        *)
            CLAUDE_ARGS+=("$1")
            shift
            ;;
    esac
done

# Handle cleanup command
if [[ "$DO_CLEANUP" == "true" ]]; then
    cleanup_proxy
    exit 0
fi

# Handle auth mode: run Claude on the host (not Docker) to complete OAuth flows.
# OAuth-based plugins (Slack, Linear) redirect to localhost for callbacks. This
# doesn't work inside Docker because the browser is on the host. Running Claude
# directly on the host with the sandbox auth dir lets OAuth callbacks succeed.
# Tokens are stored in AUTH_DIR which is later mounted into Docker.
if [[ "$AUTH_MODE" == "true" ]]; then
    ensure_auth_dir

    # Pre-flight: check that host-side dependencies for MCP servers are available.
    # workspace-mcp is needed for Google Workspace OAuth (browser callback flow).
    if ! command -v workspace-mcp &>/dev/null; then
        echo -e "${YELLOW}Warning: workspace-mcp not found on host${NC}"
        echo -e "Google Workspace OAuth requires workspace-mcp installed locally."
        echo -e "Install it with:"
        echo ""
        echo -e "  pipx install workspace-mcp==1.11.1"
        echo ""
        echo -e "(If you don't have pipx: brew install pipx && pipx ensurepath)"
        echo ""
    fi

    # Map CLAUDE_SANDBOX_* env vars so MCP servers can find credentials.
    # In Docker mode these are passed via -e flags; in auth mode we export
    # them here so child processes (workspace-mcp, etc.) inherit them.
    if [[ -n "${CLAUDE_SANDBOX_GOOGLE_CLIENT_ID:-}" && -n "${CLAUDE_SANDBOX_GOOGLE_CLIENT_SECRET:-}" ]]; then
        export GOOGLE_OAUTH_CLIENT_ID="$CLAUDE_SANDBOX_GOOGLE_CLIENT_ID"
        export GOOGLE_OAUTH_CLIENT_SECRET="$CLAUDE_SANDBOX_GOOGLE_CLIENT_SECRET"
        echo -e "${GREEN}Google Workspace OAuth: credentials available (from CLAUDE_SANDBOX_GOOGLE_*)${NC}"
    else
        echo -e "${YELLOW}Warning: CLAUDE_SANDBOX_GOOGLE_CLIENT_ID and/or CLAUDE_SANDBOX_GOOGLE_CLIENT_SECRET not set${NC}"
        echo -e "Google Workspace OAuth requires these env vars. Set them and re-run."
    fi

    # Store workspace-mcp tokens inside the auth dir so they persist and
    # are available when mounted into Docker later.
    export WORKSPACE_MCP_CREDENTIALS_DIR="$AUTH_DIR/.google-workspace-mcp"
    mkdir -p "$WORKSPACE_MCP_CREDENTIALS_DIR"

    if [[ -n "${CLAUDE_SANDBOX_PYLON_API_TOKEN:-}" ]]; then
        export PYLON_API_TOKEN="$CLAUDE_SANDBOX_PYLON_API_TOKEN"
        echo -e "${GREEN}Pylon API: available (from CLAUDE_SANDBOX_PYLON_API_TOKEN)${NC}"
    fi

    echo -e "${GREEN}Starting Claude on host for plugin authentication...${NC}"
    echo -e "${YELLOW}OAuth callbacks will work because Claude is running locally.${NC}"
    echo -e "${YELLOW}Auth dir: ${AUTH_DIR}${NC}"
    echo ""
    echo "Authenticate your plugins (e.g. Slack, Linear, Google Workspace), then exit with /exit."
    echo "For Google Workspace: ask Claude to read your Gmail or Calendar to trigger OAuth."
    echo "Next time you run claude-sandbox, the tokens will be available in Docker."
    echo ""
    CLAUDE_CONFIG_DIR="$AUTH_DIR" exec claude "${CLAUDE_ARGS[@]}"
fi

# Build if requested or needed
if [[ "$FORCE_BUILD" == "true" ]]; then
    build_image
    # Full proxy cleanup so it gets rebuilt with updated config/allowlist
    docker stop "$PROXY_CONTAINER_NAME" 2>/dev/null && docker rm "$PROXY_CONTAINER_NAME" 2>/dev/null || true
    docker network rm "$PROXY_NETWORK_NAME" 2>/dev/null || true
    docker rmi "$PROXY_IMAGE" 2>/dev/null || true
else
    ensure_image
fi

ensure_auth_dir

# Determine command to run
if [[ "$NETWORK_AUDIT" == "true" ]]; then
    CMD="network-audit"
elif [[ "$START_SHELL" == "true" ]]; then
    CMD="bash"
else
    CMD="claude"
fi

# Bypass permissions in Docker sandbox mode (auth mode uses interactive permissions).
# This is a CLI flag rather than a settings.json value so that --auth mode
# (which shares the same settings.json) gets normal interactive permissions.
if [[ "$CMD" == "claude" ]]; then
    CLAUDE_ARGS=("--dangerously-skip-permissions" "${CLAUDE_ARGS[@]}")
fi

echo -e "${GREEN}Starting sandbox in: $(pwd)${NC}"
echo -e "${YELLOW}Mounted as /workspace (read-write)${NC}"
if [[ "$NO_COMMIT" == "true" ]]; then
    echo -e "${YELLOW}Git commits disabled (use git-draft-commit)${NC}"
else
    echo -e "${YELLOW}Git commits allowed, push blocked${NC}"
    # Show git identity status
    GIT_NAME_CHECK=$(git config user.name 2>/dev/null || true)
    GIT_EMAIL_CHECK=$(git config user.email 2>/dev/null || true)
    if [[ -n "$GIT_NAME_CHECK" && -n "$GIT_EMAIL_CHECK" ]]; then
        echo -e "${GREEN}Git identity: $GIT_NAME_CHECK <$GIT_EMAIL_CHECK>${NC}"
    else
        echo -e "${RED}Warning: Git identity not configured on host (git config user.name/user.email)${NC}"
    fi
fi

# Port exposure info
if [[ ${#EXPOSED_PORTS[@]} -gt 0 ]]; then
    echo -e "${GREEN}Exposed ports: ${EXPOSED_PORTS[*]}${NC}"
    echo -e "  Access via: http://localhost:<port>"
else
    echo -e "${YELLOW}No ports exposed (use -p/--port to expose web servers)${NC}"
    echo -e "  Example: claude-sandbox -p 3000 -p 8080"
fi
echo ""

# Build env var args
ENV_ARGS=(
    -e CLAUDE_CONFIG_DIR=/home/sandbox/.claude
    -e CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS=1  # Enable multi-agent teams
)
if [[ "$NO_COMMIT" == "true" ]]; then
    ENV_ARGS+=(-e SANDBOX_NO_COMMIT=1)
else
    # Pass through git identity from host when commits are allowed
    GIT_NAME=$(git config user.name 2>/dev/null || true)
    GIT_EMAIL=$(git config user.email 2>/dev/null || true)
    if [[ -n "$GIT_NAME" ]]; then
        ENV_ARGS+=(-e "GIT_AUTHOR_NAME=$GIT_NAME" -e "GIT_COMMITTER_NAME=$GIT_NAME")
    fi
    if [[ -n "$GIT_EMAIL" ]]; then
        ENV_ARGS+=(-e "GIT_AUTHOR_EMAIL=$GIT_EMAIL" -e "GIT_COMMITTER_EMAIL=$GIT_EMAIL")
    fi
fi

# Service credentials use CLAUDE_SANDBOX_* env vars to avoid accidentally passing
# broad-access tokens from other tools. The sandbox maps them to what plugins/servers expect.
#
# GitHub: CLAUDE_SANDBOX_GITHUB_PAT -> GH_TOKEN (gh CLI)
#         Must be a fine-grained token with read-only repository permissions.
# Google: CLAUDE_SANDBOX_GOOGLE_CLIENT_ID -> GOOGLE_OAUTH_CLIENT_ID
#         CLAUDE_SANDBOX_GOOGLE_CLIENT_SECRET -> GOOGLE_OAUTH_CLIENT_SECRET
#         OAuth consent screen must only have *.readonly scopes.
# Pylon:  CLAUDE_SANDBOX_PYLON_API_TOKEN -> PYLON_API_TOKEN
#         Write operations blocked by deny list in settings.json.
if [[ -n "${CLAUDE_SANDBOX_GITHUB_PAT:-}" ]]; then
    ENV_ARGS+=(-e "GH_TOKEN=$CLAUDE_SANDBOX_GITHUB_PAT")
    echo -e "${GREEN}GitHub PAT: available (from CLAUDE_SANDBOX_GITHUB_PAT)${NC}"
elif [[ -n "${GITHUB_PERSONAL_ACCESS_TOKEN:-}" ]]; then
    echo -e "${YELLOW}Warning: GITHUB_PERSONAL_ACCESS_TOKEN is set but not used.${NC}"
    echo -e "${YELLOW}  Set CLAUDE_SANDBOX_GITHUB_PAT to a read-only fine-grained PAT instead.${NC}"
fi

if [[ -n "${CLAUDE_SANDBOX_GOOGLE_CLIENT_ID:-}" && -n "${CLAUDE_SANDBOX_GOOGLE_CLIENT_SECRET:-}" ]]; then
    ENV_ARGS+=(-e "GOOGLE_OAUTH_CLIENT_ID=$CLAUDE_SANDBOX_GOOGLE_CLIENT_ID" -e "GOOGLE_OAUTH_CLIENT_SECRET=$CLAUDE_SANDBOX_GOOGLE_CLIENT_SECRET")
    echo -e "${GREEN}Google Workspace OAuth: available (from CLAUDE_SANDBOX_GOOGLE_*)${NC}"
fi
# Point workspace-mcp at credentials stored in the auth dir (written during --auth).
# The auth dir is mounted at /home/sandbox/.claude inside Docker.
ENV_ARGS+=(-e "WORKSPACE_MCP_CREDENTIALS_DIR=/home/sandbox/.claude/.google-workspace-mcp")

if [[ -n "${CLAUDE_SANDBOX_PYLON_API_TOKEN:-}" ]]; then
    ENV_ARGS+=(-e "PYLON_API_TOKEN=$CLAUDE_SANDBOX_PYLON_API_TOKEN")
    echo -e "${GREEN}Pylon API: available (from CLAUDE_SANDBOX_PYLON_API_TOKEN)${NC}"
fi

# Build port mapping args
PORT_ARGS=()
for port in "${EXPOSED_PORTS[@]}"; do
    PORT_ARGS+=(-p "$port:$port")
done

# Build credential volume mounts (read-only)
CRED_ARGS=()
if [[ -d "$HOME/.codex" ]]; then
    CRED_ARGS+=(-v "$HOME/.codex:/home/sandbox/.codex:ro")
    echo -e "${GREEN}Codex credentials: mounted from ~/.codex${NC}"
fi
if [[ -d "$HOME/.gemini" ]]; then
    CRED_ARGS+=(-v "$HOME/.gemini:/home/sandbox/.gemini:ro")
    echo -e "${GREEN}Gemini credentials: mounted from ~/.gemini${NC}"
fi

# Google Workspace MCP tokens are stored in $AUTH_DIR/.google-workspace-mcp
# (written during --auth, read in Docker). The auth dir is already mounted
# at /home/sandbox/.claude, so no separate mount is needed -- just ensure
# the directory exists.
mkdir -p "$AUTH_DIR/.google-workspace-mcp"

# Egress filtering setup
NETWORK_ARGS=()
PROXY_ENV_ARGS=()
HOST_ARGS=(--add-host=host.docker.internal:host-gateway)

if [[ "$NO_EGRESS_FILTER" == "true" ]]; then
    echo -e "${RED}WARNING: Egress filtering disabled -- sandbox has unrestricted internet access${NC}"
    # Explicitly unset proxy env vars so global-agent is truly a no-op.
    # Prevents corporate proxy leakage if user has HTTP_PROXY set on host.
    PROXY_ENV_ARGS=(
        -e "GLOBAL_AGENT_HTTP_PROXY="
        -e "GLOBAL_AGENT_HTTPS_PROXY="
    )
else
    ensure_proxy_network
    ensure_proxy
    NETWORK_ARGS=(
        --network "$PROXY_NETWORK_NAME"
        --sysctl net.ipv6.conf.all.disable_ipv6=1  # Defense-in-depth: block IPv6 bypass
    )
    PROXY_ENV_ARGS=(
        -e "http_proxy=http://${PROXY_CONTAINER_NAME}:${PROXY_PORT}"
        -e "https_proxy=http://${PROXY_CONTAINER_NAME}:${PROXY_PORT}"
        -e "HTTP_PROXY=http://${PROXY_CONTAINER_NAME}:${PROXY_PORT}"
        -e "HTTPS_PROXY=http://${PROXY_CONTAINER_NAME}:${PROXY_PORT}"
        -e "ALL_PROXY=http://${PROXY_CONTAINER_NAME}:${PROXY_PORT}"
        -e "all_proxy=http://${PROXY_CONTAINER_NAME}:${PROXY_PORT}"
        -e "GLOBAL_AGENT_HTTP_PROXY=http://${PROXY_CONTAINER_NAME}:${PROXY_PORT}"
        -e "GLOBAL_AGENT_HTTPS_PROXY=http://${PROXY_CONTAINER_NAME}:${PROXY_PORT}"
        -e "no_proxy=localhost,127.0.0.1,${PROXY_CONTAINER_NAME}"
        -e "NO_PROXY=localhost,127.0.0.1,${PROXY_CONTAINER_NAME}"
    )
    # Remove --add-host when egress filtering is active to prevent bypass via host.docker.internal
    HOST_ARGS=()
    echo -e "${GREEN}Egress filtering: enabled (proxy: ${PROXY_CONTAINER_NAME}:${PROXY_PORT})${NC}"
fi

# Run the container
# --user: Run as current user so files created in /workspace have correct ownership on host
# HOME=/home/sandbox: Matches the directory created in Dockerfile (chmod 777 so any UID can write)
# CLAUDE_CONFIG_DIR: Tells Claude where to find/store auth and config
# Auth directory mounted for credential persistence across runs
# AI tool credentials mounted read-only for MCP server access
exec docker run -it --rm \
    --name "$CONTAINER_NAME" \
    --hostname claude-sandbox \
    --user "$(id -u):$(id -g)" \
    "${HOST_ARGS[@]}" \
    "${NETWORK_ARGS[@]}" \
    "${ENV_ARGS[@]}" \
    "${PROXY_ENV_ARGS[@]}" \
    "${PORT_ARGS[@]}" \
    "${CRED_ARGS[@]}" \
    -v "$(pwd):/workspace" \
    -v "${AUTH_DIR}:/home/sandbox/.claude" \
    -w /workspace \
    --memory=8g \
    --cpus=4 \
    "$IMAGE_NAME" \
    "$CMD" "${CLAUDE_ARGS[@]}"
