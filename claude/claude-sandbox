#!/usr/bin/env bash
# claude-sandbox - Run Claude Code in a sandboxed Docker container
# Drop this in your PATH (e.g., ~/.local/bin/claude-sandbox)

set -e

IMAGE_NAME="claude-sandbox"
CONTAINER_NAME="claude-sandbox-$$"
# Use a host directory instead of Docker volume for auth persistence
# Docker volumes are created as root, causing permission issues with --user
AUTH_DIR="$HOME/.claude-sandbox-auth"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

usage() {
    echo "Usage: claude-sandbox [OPTIONS] [CLAUDE_ARGS...]"
    echo ""
    echo "Run Claude Code in a sandboxed Docker container"
    echo ""
    echo "Options:"
    echo "  -b, --build       Force rebuild the Docker image"
    echo "  -s, --shell       Start a bash shell instead of Claude"
    echo "  -n, --no-commit   Block git commits (default: commits allowed, push blocked)"
    echo "  -p, --port PORT   Expose a port (can be used multiple times)"
    echo "  -h, --help        Show this help message"
    echo ""
    echo "Examples:"
    echo "  claude-sandbox                    # Start Claude in current directory"
    echo "  claude-sandbox --shell            # Get a shell in the sandbox"
    echo "  claude-sandbox -b                 # Rebuild image and start Claude"
    echo "  claude-sandbox -n                 # Block commits, require host review"
    echo "  claude-sandbox -p 3000 -p 8080    # Expose ports 3000 and 8080"
    echo "  claude-sandbox \"fix the tests\"    # Start Claude with initial prompt"
}

build_image() {
    echo -e "${YELLOW}Building Docker image...${NC}"

    # Check for Dockerfile in known locations
    DOCKERFILE=""
    if [[ -f "$HOME/.config/claude-sandbox/Dockerfile" ]]; then
        DOCKERFILE="$HOME/.config/claude-sandbox/Dockerfile"
    elif [[ -f "$HOME/.claude-sandbox/Dockerfile" ]]; then
        DOCKERFILE="$HOME/.claude-sandbox/Dockerfile"
    else
        echo -e "${RED}Error: Dockerfile not found${NC}"
        echo "Place Dockerfile.claude-sandbox at one of:"
        echo "  ~/.config/claude-sandbox/Dockerfile"
        echo "  ~/.claude-sandbox/Dockerfile"
        exit 1
    fi

    # Resolve symlink to get actual path (Docker doesn't follow symlinks well)
    DOCKERFILE="$(readlink -f "$DOCKERFILE")"
    echo -e "Using dockerfile at: ${DOCKERFILE}"

    # Build with logging - output goes to both terminal and log file
    local log_file="$AUTH_DIR/build.log"
    mkdir -p "$AUTH_DIR"
    echo "Build started at $(date)" > "$log_file"
    echo "Dockerfile: $DOCKERFILE" >> "$log_file"
    echo "---" >> "$log_file"

    # Use timestamp as cache-buster to force fresh Claude Code install
    if docker build --build-arg CLAUDE_CACHEBUST="$(date +%s)" \
        -t "$IMAGE_NAME" -f "$DOCKERFILE" "$(dirname "$DOCKERFILE")" 2>&1 | tee -a "$log_file"; then
        echo -e "${GREEN}Image built successfully${NC}"
        echo "---" >> "$log_file"
        echo "Build completed successfully at $(date)" >> "$log_file"
    else
        echo -e "${RED}Build failed!${NC}"
        echo -e "Log saved to: ${YELLOW}$log_file${NC}"
        echo "---" >> "$log_file"
        echo "Build FAILED at $(date)" >> "$log_file"
        exit 1
    fi
}

ensure_image() {
    if ! docker image inspect "$IMAGE_NAME" &>/dev/null; then
        echo -e "${YELLOW}Image not found, building...${NC}"
        build_image
    fi
}

ensure_auth_dir() {
    if [[ ! -d "$AUTH_DIR" ]]; then
        echo -e "${YELLOW}Creating auth directory...${NC}"
        mkdir -p "$AUTH_DIR"
    fi

    # Ensure settings.json has bypassPermissions mode
    # Claude Code may create/modify this file when you approve commands,
    # so we need to update it in place rather than overwrite it
    local settings_file="$AUTH_DIR/settings.json"
    if [[ ! -f "$settings_file" ]]; then
        echo -e "${YELLOW}Creating settings with bypass permissions...${NC}"
        cat > "$settings_file" <<'SETTINGS'
{
  "permissions": {
    "allow": [],
    "deny": [],
    "defaultMode": "bypassPermissions"
  }
}
SETTINGS
    elif ! grep -q '"defaultMode"[[:space:]]*:[[:space:]]*"bypassPermissions"' "$settings_file"; then
        echo -e "${YELLOW}Updating settings to bypass permissions mode...${NC}"
        # Use python to safely update JSON (preserves existing allow list)
        python3 -c "
import json, sys
settings_file = sys.argv[1]
with open(settings_file, 'r') as f:
    settings = json.load(f)
if 'permissions' not in settings:
    settings['permissions'] = {}
settings['permissions']['defaultMode'] = 'bypassPermissions'
with open(settings_file, 'w') as f:
    json.dump(settings, f, indent=2)
" "$settings_file"
    fi

    # Ensure MCP config has required servers (Codex, Gemini, Playwright)
    # Merges into existing config, preserving user-added servers
    local mcp_file="$AUTH_DIR/mcp.json"
    local added
    added=$(python3 << 'PYTHON' "$mcp_file"
import json
import sys

mcp_file = sys.argv[1]

# Required MCP servers for sandbox
required_servers = {
    'codex': {
        'command': 'codex-mcp-server',
        'args': [],
        'env': {}
    },
    'gemini': {
        'command': 'gemini-mcp',
        'args': [],
        'env': {}
    },
    'playwright': {
        'command': 'npx',
        'args': ['@playwright/mcp@latest', '--browser', 'chromium', '--headless', '--no-sandbox', '--isolated'],
        'env': {}
    }
}

# Load existing config or create new
try:
    with open(mcp_file, 'r') as f:
        config = json.load(f)
except (FileNotFoundError, json.JSONDecodeError):
    config = {}

if 'mcpServers' not in config:
    config['mcpServers'] = {}

# Add missing servers
added = []
for name, server in required_servers.items():
    if name not in config['mcpServers']:
        config['mcpServers'][name] = server
        added.append(name)

# Write back if changes were made
if added:
    with open(mcp_file, 'w') as f:
        json.dump(config, f, indent=2)
    print(', '.join(added))
PYTHON
)

    if [[ -n "$added" ]]; then
        echo -e "${YELLOW}Added MCP servers: ${added}${NC}"
    fi
}

# Parse arguments
FORCE_BUILD=false
START_SHELL=false
NO_COMMIT=false
EXPOSED_PORTS=()
CLAUDE_ARGS=()

while [[ $# -gt 0 ]]; do
    case $1 in
        -b|--build)
            FORCE_BUILD=true
            shift
            ;;
        -s|--shell)
            START_SHELL=true
            shift
            ;;
        -n|--no-commit)
            NO_COMMIT=true
            shift
            ;;
        -p|--port)
            if [[ -z "$2" || "$2" == -* ]]; then
                echo -e "${RED}Error: --port requires a port number${NC}"
                exit 1
            fi
            EXPOSED_PORTS+=("$2")
            shift 2
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        *)
            CLAUDE_ARGS+=("$1")
            shift
            ;;
    esac
done

# Build if requested or needed
if [[ "$FORCE_BUILD" == "true" ]]; then
    build_image
else
    ensure_image
fi

ensure_auth_dir

# Determine command to run
if [[ "$START_SHELL" == "true" ]]; then
    CMD="bash"
else
    CMD="claude"
fi

echo -e "${GREEN}Starting sandbox in: $(pwd)${NC}"
echo -e "${YELLOW}Mounted as /workspace (read-write)${NC}"
if [[ "$NO_COMMIT" == "true" ]]; then
    echo -e "${YELLOW}Git commits disabled (use git-draft-commit)${NC}"
else
    echo -e "${YELLOW}Git commits allowed, push blocked${NC}"
    # Show git identity status
    GIT_NAME_CHECK=$(git config user.name 2>/dev/null || true)
    GIT_EMAIL_CHECK=$(git config user.email 2>/dev/null || true)
    if [[ -n "$GIT_NAME_CHECK" && -n "$GIT_EMAIL_CHECK" ]]; then
        echo -e "${GREEN}Git identity: $GIT_NAME_CHECK <$GIT_EMAIL_CHECK>${NC}"
    else
        echo -e "${RED}Warning: Git identity not configured on host (git config user.name/user.email)${NC}"
    fi
fi

# Port exposure info
if [[ ${#EXPOSED_PORTS[@]} -gt 0 ]]; then
    echo -e "${GREEN}Exposed ports: ${EXPOSED_PORTS[*]}${NC}"
    echo -e "  Access via: http://localhost:<port>"
else
    echo -e "${YELLOW}No ports exposed (use -p/--port to expose web servers)${NC}"
    echo -e "  Example: claude-sandbox -p 3000 -p 8080"
fi
echo ""

# Build env var args
ENV_ARGS=(-e CLAUDE_CONFIG_DIR=/home/sandbox/.claude)
if [[ "$NO_COMMIT" == "true" ]]; then
    ENV_ARGS+=(-e SANDBOX_NO_COMMIT=1)
else
    # Pass through git identity from host when commits are allowed
    GIT_NAME=$(git config user.name 2>/dev/null || true)
    GIT_EMAIL=$(git config user.email 2>/dev/null || true)
    if [[ -n "$GIT_NAME" ]]; then
        ENV_ARGS+=(-e "GIT_AUTHOR_NAME=$GIT_NAME" -e "GIT_COMMITTER_NAME=$GIT_NAME")
    fi
    if [[ -n "$GIT_EMAIL" ]]; then
        ENV_ARGS+=(-e "GIT_AUTHOR_EMAIL=$GIT_EMAIL" -e "GIT_COMMITTER_EMAIL=$GIT_EMAIL")
    fi
fi

# Build port mapping args
PORT_ARGS=()
for port in "${EXPOSED_PORTS[@]}"; do
    PORT_ARGS+=(-p "$port:$port")
done

# Build AI tool credential volume mounts (read-only)
# These allow Codex and Gemini MCP servers in the sandbox to use host credentials
AI_CRED_ARGS=()
if [[ -d "$HOME/.codex" ]]; then
    AI_CRED_ARGS+=(-v "$HOME/.codex:/home/sandbox/.codex:ro")
    echo -e "${GREEN}Codex credentials: mounted from ~/.codex${NC}"
fi
if [[ -d "$HOME/.gemini" ]]; then
    AI_CRED_ARGS+=(-v "$HOME/.gemini:/home/sandbox/.gemini:ro")
    echo -e "${GREEN}Gemini credentials: mounted from ~/.gemini${NC}"
fi

# Run the container
# --user: Run as current user so files created in /workspace have correct ownership on host
# HOME=/home/sandbox: Matches the directory created in Dockerfile (chmod 777 so any UID can write)
# CLAUDE_CONFIG_DIR: Tells Claude where to find/store auth and config
# Auth directory mounted for credential persistence across runs
# AI tool credentials mounted read-only for MCP server access
exec docker run -it --rm \
    --name "$CONTAINER_NAME" \
    --hostname claude-sandbox \
    --user "$(id -u):$(id -g)" \
    --add-host=host.docker.internal:host-gateway \
    "${ENV_ARGS[@]}" \
    "${PORT_ARGS[@]}" \
    "${AI_CRED_ARGS[@]}" \
    -v "$(pwd):/workspace" \
    -v "${AUTH_DIR}:/home/sandbox/.claude" \
    -w /workspace \
    --memory=8g \
    --cpus=4 \
    "$IMAGE_NAME" \
    $CMD "${CLAUDE_ARGS[@]}"
